# otg_authn_006_tester.py
# OTG-AUTHN-006: Testing for Browser Cache Weakness
# OSCP-Style Vulnerability Tester for DVWA (localhost XAMPP)
# Generated by AI Security Assistant

import requests
import datetime
from bs4 import BeautifulSoup
import urllib3

# Disable SSL warnings for localhost
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# === CONFIGURATION ===
BASE_URL = "http://localhost/dvwa"
LOGIN_URL = f"{BASE_URL}/login.php"
USER_AGENT = "OTG-AUTHN-006 Tester v1.0"
USERNAME = "admin"
PASSWORD = "password"

# Pages to test
TEST_PAGES = [
    "/login.php",
    "/index.php",
    "/vulnerabilities/brute/",
    "/vulnerabilities/sqli/",
    "/security.php",
    "/phpinfo.php"
]

# Headers
headers = {
    'User-Agent': USER_AGENT,
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Connection': 'close'
}

def banner():
    print(r"""
    =====================================================
     OTG-AUTHN-006 - Testing for Browser Cache Weakness
             OSCP-Style Security Assessment
    =====================================================
    """)

def test_connection():
    try:
        resp = requests.get(LOGIN_URL, headers=headers, timeout=10, verify=False)
        if resp.status_code == 200:
            return True, resp
        else:
            return False, resp.status_code
    except requests.exceptions.RequestException as e:
        return False, str(e)

def extract_csrf_token(response):
    soup = BeautifulSoup(response.text, 'html.parser')
    token_elem = soup.find('input', {'name': 'user_token'})
    if token_elem:
        return token_elem['value']
    return None

def analyze_cache_headers(response, page_url):
    """Analyze cache-related headers for security issues"""
    cache_headers = {}
    
    # Extract relevant headers
    cache_headers['Cache-Control'] = response.headers.get('Cache-Control', 'NOT SET')
    cache_headers['Pragma'] = response.headers.get('Pragma', 'NOT SET')
    cache_headers['Expires'] = response.headers.get('Expires', 'NOT SET')
    cache_headers['ETag'] = response.headers.get('ETag', 'NOT SET')
    cache_headers['Last-Modified'] = response.headers.get('Last-Modified', 'NOT SET')
    
    # Security analysis
    issues = []
    
    # Check Cache-Control
    cache_control = cache_headers['Cache-Control'].lower()
    if cache_control == 'not set':
        issues.append("Missing Cache-Control header")
    else:
        if 'no-store' not in cache_control:
            issues.append("Missing 'no-store' directive")
        if 'no-cache' not in cache_control:
            issues.append("Missing 'no-cache' directive")
        if 'public' in cache_control:
            issues.append("Contains 'public' directive (insecure for sensitive content)")
        if 'private' not in cache_control and 'no-store' not in cache_control:
            issues.append("Missing 'private' directive for authenticated content")
    
    # Check Pragma
    pragma = cache_headers['Pragma'].lower()
    if pragma == 'not set':
        issues.append("Missing Pragma header")
    elif 'no-cache' not in pragma:
        issues.append("Pragma header missing 'no-cache' directive")
    
    # Check Expires
    expires = cache_headers['Expires'].lower()
    if expires == 'not set':
        issues.append("Missing Expires header")
    elif expires != '0' and expires != 'thu, 01 jan 1970 00:00:00 gmt':
        issues.append("Expires header not set to 0 or past date")
    
    # Determine if page is authenticated/sensitive
    is_sensitive = any(indicator in page_url.lower() for indicator in [
        'index', 'security', 'vulnerabilities', 'phpinfo'
    ])
    
    # Additional checks for sensitive pages
    if is_sensitive:
        if cache_control != 'not set' and ('public' in cache_control or ('max-age' in cache_control and '0' not in cache_control)):
            issues.append("Sensitive page allows caching (security risk)")
    
    return {
        'url': page_url,
        'headers': cache_headers,
        'issues': issues,
        'is_sensitive': is_sensitive
    }

def test_unauthenticated_pages():
    """Test cache headers on unauthenticated pages"""
    print("[→] Testing cache headers on unauthenticated pages...")
    results = []
    
    for page in TEST_PAGES:
        url = BASE_URL + page
        try:
            resp = requests.get(url, headers=headers, verify=False, timeout=10)
            analysis = analyze_cache_headers(resp, url)
            results.append(analysis)
            print(f"[→] Tested: {page}")
        except Exception as e:
            results.append({
                'url': url,
                'error': str(e)
            })
            print(f"[!] Error testing {page}: {e}")
    
    return results

def test_authenticated_pages():
    """Test cache headers on authenticated pages"""
    print("[→] Testing cache headers on authenticated pages...")
    results = []
    
    # Login first
    session = requests.Session()
    try:
        # Get login page
        resp = session.get(LOGIN_URL, headers=headers, verify=False, timeout=10)
        csrf_token = extract_csrf_token(resp)
        
        # Login
        data = {
            'username': USERNAME,
            'password': PASSWORD,
            'Login': 'Login'
        }
        if csrf_token:
            data['user_token'] = csrf_token
            
        login_resp = session.post(LOGIN_URL, data=data, headers=headers, verify=False)
        
        if "index.php" not in login_resp.url:
            print("[!] Login failed, cannot test authenticated pages")
            return []
        
        # Test authenticated pages
        for page in TEST_PAGES:
            # Skip login page for authenticated test
            if 'login.php' in page:
                continue
                
            url = BASE_URL + page
            try:
                resp = session.get(url, headers=headers, verify=False, timeout=10)
                analysis = analyze_cache_headers(resp, url)
                results.append(analysis)
                print(f"[→] Tested authenticated: {page}")
            except Exception as e:
                results.append({
                    'url': url,
                    'error': str(e)
                })
                print(f"[!] Error testing authenticated {page}: {e}")
                
    except Exception as e:
        print(f"[!] Error during authentication: {e}")
        return []
    
    return results

def generate_html_report(result, findings, poc, recommendations):
    report_name = "OTG-AUTHN-006_Report.html"
    date_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    status_color = "#cc0000" if "Failed" in result else "#008800"

    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OTG-AUTHN-006 Security Assessment Report</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background-color: #f4f4f4;
            color: #000;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        header {{
            background-color: #003366;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.4em;
            margin: -20px -20px 20px -20px;
        }}
        h1, h2, h3 {{
            color: #003366;
            border-bottom: 1px solid #003366;
            padding-bottom: 5px;
        }}
        .field {{
            margin-bottom: 10px;
        }}
        .label {{
            font-weight: bold;
            display: inline-block;
            width: 200px;
        }}
        .value {{
            display: inline;
        }}
        .status {{
            color: {status_color};
            font-weight: bold;
        }}
        pre {{
            background: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            overflow: auto;
            font-size: 0.9em;
        }}
        footer {{
            margin-top: 30px;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }}
        .risk {{
            font-weight: bold;
            color: #cc0000;
        }}
        .success {{
            color: #008800;
            font-weight: bold;
        }}
        .failed {{
            color: #cc0000;
            font-weight: bold;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        .vulnerable {{
            background-color: #ffe6e6;
        }}
        .secure {{
            background-color: #e6ffe6;
        }}
        .issue {{
            color: #cc0000;
            font-weight: bold;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            OWASP Web Security Testing Guide - OTG-AUTHN-006
        </header>

        <h1>OTG-AUTHN-006: Testing for Browser Cache Weakness</h1>

        <div class="field"><span class="label">Test Date:</span> <span class="value">{date_str}</span></div>
        <div class="field"><span class="label">Target URL:</span> <span class="value">{BASE_URL}</span></div>
        <div class="field"><span class="label">Test Result:</span> <span class="value status">{result}</span></div>

        <h2>Vulnerability Description</h2>
        <p>
            Browser cache weakness occurs when web applications fail to properly instruct browsers 
            and intermediate caches not to store sensitive content. This can lead to unauthorized 
            access to authenticated data through browser history, cache files, or shared computer access.
        </p>
        <p>
            This test evaluates whether the application sets appropriate cache control headers 
            to prevent sensitive content from being stored in browser caches.
        </p>

        <h2>Impact</h2>
        <p class="risk">Medium</p>
        <p>
            Improper cache control can expose sensitive information such as user credentials, 
            personal data, and application functionality to unauthorized users. On shared or 
            public computers, cached sensitive pages can be accessed by subsequent users.
        </p>

        <h2>Test Findings</h2>
        <pre>{findings}</pre>

        <h2>Proof of Concept (PoC)</h2>
        <p>The following commands demonstrate insecure cache headers:</p>
        <pre><code>{poc}</code></pre>

        <h2>Remediation / Recommendations</h2>
        <p>{recommendations}</p>

        <h2>References</h2>
        <ul>
            <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authentication_Testing/06-Testing_for_Browser_Cache_Weakness" target="_blank">
                OWASP WSTG - OTG-AUTHN-006</a></li>
            <li><a href="https://owasp.org/www-project-secure-headers/" target="_blank">
                OWASP Secure Headers Project</a></li>
            <li><a href="https://httpwg.org/specs/rfc9111.html" target="_blank">
                RFC 9111 - HTTP Caching</a></li>
            <li><a href="https://owasp.org/www-project-top-ten/2017/A03_2017-Sensitive_Data_Exposure" target="_blank">
                OWASP Top 10 - A03:2017 Sensitive Data Exposure</a></li>
            <li>Set Cache-Control: no-store, no-cache, must-revalidate, private</li>
            <li>Add Pragma: no-cache for HTTP/1.0 compatibility</li>
            <li>Set Expires: 0 to prevent caching</li>
            <li>Apply to all authenticated and sensitive pages</li>
        </ul>

        <footer>
            OSCP-Style Security Assessment Report | Generated by OTG-AUTHN-006 Tester
        </footer>
    </div>
</body>
</html>
    """

    with open(report_name, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"[+] Report generated: {report_name}")

def main():
    banner()

    print("[+] Starting OTG-AUTHN-006 test...")
    
    # Test connectivity
    print("[✓] Testing connectivity to target...")
    connected, resp_or_err = test_connection()
    if not connected:
        print(f"[-] Failed to connect to {LOGIN_URL}")
        print(f"Error: {resp_or_err}")
        return

    print(f"[✓] Connected to {LOGIN_URL}")

    # Test unauthenticated pages
    unauth_results = test_unauthenticated_pages()
    
    # Test authenticated pages
    auth_results = test_authenticated_pages()
    
    # Combine results
    all_results = unauth_results + auth_results
    
    # Analyze findings
    findings_text = ""
    insecure_pages = []
    poc_commands = []
    
    # Process results
    for result in all_results:
        if 'error' in result:
            findings_text += f"ERROR testing {result['url']}: {result['error']}\n\n"
            continue
            
        url = result['url']
        headers = result['headers']
        issues = result['issues']
        is_sensitive = result['is_sensitive']
        
        findings_text += f"Page: {url}\n"
        findings_text += f"  Sensitive Content: {'YES' if is_sensitive else 'NO'}\n"
        findings_text += f"  Cache-Control: {headers['Cache-Control']}\n"
        findings_text += f"  Pragma: {headers['Pragma']}\n"
        findings_text += f"  Expires: {headers['Expires']}\n"
        
        if issues:
            findings_text += "  Issues Found:\n"
            for issue in issues:
                findings_text += f"    - {issue}\n"
                if is_sensitive or 'no-store' in issue or 'public' in issue:
                    insecure_pages.append({
                        'url': url,
                        'issue': issue
                    })
        else:
            findings_text += "  Issues Found: None\n"
        
        findings_text += "\n"
        
        # Add to PoC if insecure
        if issues:
            poc_commands.append(f"# Testing cache headers for {url}")
            poc_commands.append(f"curl -v \"{url}\" | grep -i -E 'cache-control|pragma|expires'")
    
    # Generate report
    if insecure_pages:
        result = "Failed"
        poc = "\n".join(poc_commands)
        
        recommendations = """
The application has browser cache weaknesses that must be addressed immediately:

1. Set proper cache control headers on all authenticated and sensitive pages:
   Cache-Control: no-store, no-cache, must-revalidate, private
   Pragma: no-cache
   Expires: 0

2. Never allow caching of authenticated content or sensitive data.

3. Use the following header configuration for sensitive pages:
   Header set Cache-Control "no-store, no-cache, must-revalidate, private"
   Header set Pragma "no-cache"
   Header set Expires "0"

4. For static public content, use appropriate caching with versioning:
   Cache-Control: public, max-age=31536000

5. Implement cache control in your application framework:
   - PHP: header('Cache-Control: no-store, no-cache, must-revalidate, private');
   - Apache: Use mod_headers to set appropriate headers
   - Nginx: add_header directives for cache control

6. Regularly audit cache headers during security testing.

7. Test on both HTTP and HTTPS to ensure consistent header behavior.
"""
    else:
        result = "Passed"
        findings_text += "No browser cache weaknesses detected.\n"
        findings_text += "All tested pages have appropriate cache control headers.\n"
        poc = "No insecure cache implementations found."
        
        recommendations = """
The application properly implements browser cache controls. However, continue to:

1. Regularly audit cache headers during security reviews.
2. Ensure new features and pages implement proper cache controls.
3. Test cache behavior in different browsers and proxy environments.
4. Monitor for changes in caching requirements due to new functionality.
5. Document cache policies for developers and security teams.
6. Consider implementing automated header validation in CI/CD pipelines.
7. Review cache headers during penetration testing and code reviews.
"""

    generate_html_report(result, findings_text, poc, recommendations)
    print("[+] Test completed.")

if __name__ == "__main__":
    main()