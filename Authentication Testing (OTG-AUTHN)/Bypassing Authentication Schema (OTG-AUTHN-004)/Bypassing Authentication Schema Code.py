# otg_authn_004_tester.py
# OTG-AUTHN-004: Testing for Bypassing Authentication Schema
# OSCP-Style Vulnerability Tester for DVWA (localhost XAMPP)
# Generated by AI Security Assistant

import requests
import datetime
from bs4 import BeautifulSoup
import urllib3

# Disable SSL warnings for localhost
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# === CONFIGURATION ===
BASE_URL = "http://localhost/dvwa"
LOGIN_URL = f"{BASE_URL}/login.php"
INDEX_URL = f"{BASE_URL}/index.php"
USER_AGENT = "OTG-AUTHN-004 Tester v1.0"

# Protected pages to test
PROTECTED_PAGES = [
    "/index.php",
    "/vulnerabilities/brute/",
    "/vulnerabilities/sqli/",
    "/security.php",
    "/phpinfo.php"
]

# Headers
headers = {
    'User-Agent': USER_AGENT,
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Connection': 'close'
}

def banner():
    print(r"""
    =====================================================
     OTG-AUTHN-004 - Bypassing Authentication Schema
             OSCP-Style Security Assessment
    =====================================================
    """)

def test_connection():
    try:
        resp = requests.get(LOGIN_URL, headers=headers, timeout=10, verify=False)
        if resp.status_code == 200:
            return True, resp
        else:
            return False, resp.status_code
    except requests.exceptions.RequestException as e:
        return False, str(e)

def extract_csrf_token(response):
    soup = BeautifulSoup(response.text, 'html.parser')
    token_elem = soup.find('input', {'name': 'user_token'})
    if token_elem:
        return token_elem['value']
    return None

def is_authenticated(response):
    """Check if response indicates authenticated access"""
    auth_indicators = [
        "Welcome to Damn Vulnerable Web Application",
        "DVWA Security Level",
        "Logout",
        "security.php",
        "vulnerabilities"
    ]
    
    authenticated = any(indicator in response.text for indicator in auth_indicators)
    login_redirect = "login.php" in response.url or "login" in response.text.lower()
    
    return authenticated and not login_redirect

def test_direct_access(session, path):
    """Test direct access to protected pages without authentication"""
    url = BASE_URL + path
    try:
        resp = session.get(url, headers=headers, verify=False, timeout=10)
        return resp
    except requests.exceptions.RequestException as e:
        return str(e)

def test_parameter_tampering(session, path):
    """Test URL parameter tampering for authentication bypass"""
    bypass_params = [
        "?admin=1",
        "?auth=1",
        "?access=granted",
        "?login=true",
        "?authenticated=true",
        "?role=admin",
        "?debug=1"
    ]
    
    results = []
    base_url = BASE_URL + path
    
    for param in bypass_params:
        url = base_url + param
        try:
            resp = session.get(url, headers=headers, verify=False, timeout=10)
            results.append({
                'url': url,
                'status': resp.status_code,
                'authenticated': is_authenticated(resp),
                'response': resp
            })
        except requests.exceptions.RequestException as e:
            results.append({
                'url': url,
                'status': 'Error',
                'authenticated': False,
                'response': str(e)
            })
    
    return results

def test_cookie_manipulation(session, path):
    """Test cookie manipulation for authentication bypass"""
    forged_cookies = [
        {'PHPSESSID': 'admin'},
        {'user': 'admin'},
        {'authenticated': 'true'},
        {'role': 'admin'},
        {'admin': '1'}
    ]
    
    results = []
    base_url = BASE_URL + path
    
    for cookie in forged_cookies:
        try:
            # Create new session with forged cookie
            test_session = requests.Session()
            test_session.cookies.update(cookie)
            
            resp = test_session.get(base_url, headers=headers, verify=False, timeout=10)
            results.append({
                'cookies': cookie,
                'status': resp.status_code,
                'authenticated': is_authenticated(resp),
                'response': resp
            })
        except requests.exceptions.RequestException as e:
            results.append({
                'cookies': cookie,
                'status': 'Error',
                'authenticated': False,
                'response': str(e)
            })
    
    return results

def test_http_methods(session, path):
    """Test different HTTP methods for authentication bypass"""
    methods = ['HEAD', 'OPTIONS', 'GET', 'POST']
    results = []
    base_url = BASE_URL + path
    
    for method in methods:
        try:
            if method == 'HEAD':
                resp = session.head(base_url, headers=headers, verify=False, timeout=10)
            elif method == 'OPTIONS':
                resp = session.options(base_url, headers=headers, verify=False, timeout=10)
            elif method == 'POST':
                resp = session.post(base_url, headers=headers, verify=False, timeout=10)
            else:  # GET
                resp = session.get(base_url, headers=headers, verify=False, timeout=10)
                
            results.append({
                'method': method,
                'status': resp.status_code,
                'authenticated': is_authenticated(resp),
                'response': resp
            })
        except requests.exceptions.RequestException as e:
            results.append({
                'method': method,
                'status': 'Error',
                'authenticated': False,
                'response': str(e)
            })
    
    return results

def generate_html_report(result, findings, poc, recommendations):
    report_name = "OTG-AUTHN-004_Report.html"
    date_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    status_color = "#cc0000" if "Failed" in result else "#008800"

    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OTG-AUTHN-004 Security Assessment Report</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background-color: #f4f4f4;
            color: #000;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        header {{
            background-color: #003366;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.4em;
            margin: -20px -20px 20px -20px;
        }}
        h1, h2, h3 {{
            color: #003366;
            border-bottom: 1px solid #003366;
            padding-bottom: 5px;
        }}
        .field {{
            margin-bottom: 10px;
        }}
        .label {{
            font-weight: bold;
            display: inline-block;
            width: 200px;
        }}
        .value {{
            display: inline;
        }}
        .status {{
            color: {status_color};
            font-weight: bold;
        }}
        pre {{
            background: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            overflow: auto;
            font-size: 0.9em;
        }}
        footer {{
            margin-top: 30px;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }}
        .risk {{
            font-weight: bold;
            color: #cc0000;
        }}
        .success {{
            color: #008800;
            font-weight: bold;
        }}
        .failed {{
            color: #cc0000;
            font-weight: bold;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        .vulnerable {{
            background-color: #ffe6e6;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            OWASP Web Security Testing Guide - OTG-AUTHN-004
        </header>

        <h1>OTG-AUTHN-004: Testing for Bypassing Authentication Schema</h1>

        <div class="field"><span class="label">Test Date:</span> <span class="value">{date_str}</span></div>
        <div class="field"><span class="label">Target URL:</span> <span class="value">{BASE_URL}</span></div>
        <div class="field"><span class="label">Test Result:</span> <span class="value status">{result}</span></div>

        <h2>Vulnerability Description</h2>
        <p>
            Authentication bypass vulnerabilities occur when an application fails to properly enforce 
            authentication checks, allowing unauthorized users to access protected resources. This can 
            happen due to weak session management, improper access controls, or flawed authentication logic.
        </p>
        <p>
            This test evaluates various techniques that attackers might use to bypass authentication 
            mechanisms, including direct URL access, parameter tampering, cookie manipulation, and 
            HTTP method abuse.
        </p>

        <h2>Impact</h2>
        <p class="risk">High</p>
        <p>
            Successful authentication bypass allows attackers to gain unauthorized access to sensitive 
            application functionality, user data, and administrative features. This can lead to complete 
            compromise of the application and potentially the underlying system.
        </p>

        <h2>Test Findings</h2>
        <pre>{findings}</pre>

        <h2>Proof of Concept (PoC)</h2>
        <p>The following commands demonstrate successful authentication bypass:</p>
        <pre><code>{poc}</code></pre>

        <h2>Remediation / Recommendations</h2>
        <p>{recommendations}</p>

        <h2>References</h2>
        <ul>
            <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authentication_Testing/04-Testing_for_Bypassing_Authentication_Schema" target="_blank">
                OWASP WSTG - OTG-AUTHN-004</a></li>
            <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html" target="_blank">
                OWASP Access Control Cheat Sheet</a></li>
            <li><a href="https://owasp.org/www-project-top-ten/2017/A05_2017-Broken_Access_Control" target="_blank">
                OWASP Top 10 - A05:2017 Broken Access Control</a></li>
            <li>Implement server-side authentication checks on all protected resources.</li>
            <li>Never rely on client-side parameters or cookies for access control decisions.</li>
            <li>Use secure session management with proper session validation.</li>
            <li>Implement proper error handling that doesn't reveal sensitive information.</li>
        </ul>

        <footer>
            OSCP-Style Security Assessment Report | Generated by OTG-AUTHN-004 Tester
        </footer>
    </div>
</body>
</html>
    """

    with open(report_name, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"[+] Report generated: {report_name}")

def main():
    banner()

    print("[+] Starting OTG-AUTHN-004 test...")
    
    # Test connectivity
    print("[✓] Testing connectivity to target...")
    connected, resp_or_err = test_connection()
    if not connected:
        print(f"[-] Failed to connect to {LOGIN_URL}")
        print(f"Error: {resp_or_err}")
        return

    print(f"[✓] Connected to {LOGIN_URL}")

    # Initialize session
    session = requests.Session()
    
    # Track findings
    all_findings = []
    successful_bypasses = []
    
    print("[→] Testing direct access to protected pages...")
    
    # Test 1: Direct Access
    for page in PROTECTED_PAGES:
        print(f"[→] Testing: {page}")
        response = test_direct_access(session, page)
        
        if isinstance(response, str):
            finding = f"ERROR accessing {page}: {response}\n"
            all_findings.append(finding)
            continue
            
        is_auth = is_authenticated(response)
        redirect_to_login = "login.php" in response.url
        
        finding = f"Direct Access Test - {page}:\n"
        finding += f"  Status: {response.status_code}\n"
        finding += f"  URL: {response.url}\n"
        finding += f"  Authenticated Access: {'YES' if is_auth else 'NO'}\n"
        finding += f"  Redirect to Login: {'YES' if redirect_to_login else 'NO'}\n\n"
        
        all_findings.append(finding)
        
        if is_auth and not redirect_to_login:
            successful_bypasses.append({
                'method': 'Direct Access',
                'url': BASE_URL + page,
                'description': f"Direct access to {page} granted authenticated access"
            })
            print(f"[!] VULNERABILITY: Direct access bypass found for {page}")

    # Test 2: Parameter Tampering
    print("[→] Testing parameter tampering...")
    param_results = test_parameter_tampering(session, "/index.php")
    
    for result in param_results:
        is_auth = result['authenticated']
        finding = f"Parameter Tampering Test:\n"
        finding += f"  URL: {result['url']}\n"
        finding += f"  Status: {result['status']}\n"
        finding += f"  Authenticated Access: {'YES' if is_auth else 'NO'}\n\n"
        
        all_findings.append(finding)
        
        if is_auth:
            successful_bypasses.append({
                'method': 'Parameter Tampering',
                'url': result['url'],
                'description': f"Parameter tampering granted access: {result['url']}"
            })
            print(f"[!] VULNERABILITY: Parameter tampering bypass found: {result['url']}")

    # Test 3: Cookie Manipulation
    print("[→] Testing cookie manipulation...")
    cookie_results = test_cookie_manipulation(session, "/index.php")
    
    for result in cookie_results:
        is_auth = result['authenticated']
        finding = f"Cookie Manipulation Test:\n"
        finding += f"  Cookies: {result['cookies']}\n"
        finding += f"  Status: {result['status']}\n"
        finding += f"  Authenticated Access: {'YES' if is_auth else 'NO'}\n\n"
        
        all_findings.append(finding)
        
        if is_auth:
            successful_bypasses.append({
                'method': 'Cookie Manipulation',
                'cookies': result['cookies'],
                'description': f"Cookie manipulation granted access with cookies: {result['cookies']}"
            })
            print(f"[!] VULNERABILITY: Cookie manipulation bypass found with cookies: {result['cookies']}")

    # Test 4: HTTP Method Tampering
    print("[→] Testing HTTP method tampering...")
    method_results = test_http_methods(session, "/index.php")
    
    for result in method_results:
        is_auth = result['authenticated']
        finding = f"HTTP Method Test - {result['method']}:\n"
        finding += f"  Status: {result['status']}\n"
        finding += f"  Authenticated Access: {'YES' if is_auth else 'NO'}\n\n"
        
        all_findings.append(finding)
        
        if is_auth:
            successful_bypasses.append({
                'method': 'HTTP Method Tampering',
                'method_used': result['method'],
                'description': f"HTTP method {result['method']} granted access"
            })
            print(f"[!] VULNERABILITY: HTTP method tampering bypass found with method: {result['method']}")

    # Generate report
    findings_text = "".join(all_findings)
    
    if successful_bypasses:
        result = "Failed"
        poc_commands = []
        
        for bypass in successful_bypasses:
            if 'url' in bypass:
                poc_commands.append(f"curl -v \"{bypass['url']}\"")
            elif 'cookies' in bypass:
                cookie_str = "; ".join([f"{k}={v}" for k, v in bypass['cookies'].items()])
                poc_commands.append(f"curl -v --cookie \"{cookie_str}\" \"{BASE_URL}/index.php\"")
            elif 'method_used' in bypass:
                poc_commands.append(f"curl -v -X {bypass['method_used']} \"{BASE_URL}/index.php\"")
        
        poc = "\n".join(poc_commands)
        
        recommendations = """
The application contains authentication bypass vulnerabilities that must be addressed immediately:

1. Implement server-side authentication checks on ALL protected resources.
2. Never rely on client-side parameters, cookies, or headers for access control decisions.
3. Validate session integrity and user permissions before granting access to any protected page.
4. Use secure session management with proper session validation and regeneration.
5. Implement proper error handling that doesn't reveal sensitive information or access control logic.
6. Regularly audit access controls and perform penetration testing.
7. Apply the principle of least privilege - users should only have access to what they need.
8. Log and monitor access attempts to detect potential bypass attempts.
"""
    else:
        result = "Passed"
        findings_text += "No authentication bypass vulnerabilities were detected.\n"
        findings_text += "All tests showed proper authentication enforcement.\n"
        poc = "No successful bypass attempts were found."
        
        recommendations = """
The application properly enforces authentication checks. However, continue to:

1. Regularly audit access controls and authentication mechanisms.
2. Implement defense-in-depth strategies for access control.
3. Use secure session management with proper session validation.
4. Monitor for unusual access patterns that might indicate bypass attempts.
5. Keep authentication libraries and frameworks up to date.
6. Conduct regular security assessments and penetration testing.
7. Train developers on secure authentication and access control practices.
"""

    generate_html_report(result, findings_text, poc, recommendations)
    print("[+] Test completed.")

if __name__ == "__main__":
    main()