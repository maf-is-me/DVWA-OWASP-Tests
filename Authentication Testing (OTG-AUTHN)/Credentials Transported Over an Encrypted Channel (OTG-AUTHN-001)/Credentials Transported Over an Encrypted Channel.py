# otg_authn_001_tester.py
# OTG-AUTHN-001: Credentials Transported over an Encrypted Channel
# OSCP-Style Vulnerability Tester for DVWA (localhost XAMPP)
# Generated by AI Security Assistant

import requests
import datetime
import os
from bs4 import BeautifulSoup

# Disable SSL warnings for localhost
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# === CONFIGURATION ===
TARGET_URL = "http://localhost/dvwa/login.php"
LOGIN_ACTION = "http://localhost/dvwa/login.php"
DUMMY_USER = "admin"
DUMMY_PASS = "password"
USER_AGENT = "OTG-AUTHN-001 Tester v1.0"

# Headers
headers = {
    'User-Agent': USER_AGENT,
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Connection': 'close'
}

def banner():
    print(r"""
    =====================================================
     OTG-AUTHN-001 - Credentials Over Encrypted Channel
             OSCP-Style Security Assessment
    =====================================================
    """)

def test_connection():
    try:
        resp = requests.get(TARGET_URL, headers=headers, timeout=10, verify=False)
        if resp.status_code == 200:
            return True, resp
        else:
            return False, resp.status_code
    except requests.exceptions.RequestException as e:
        return False, str(e)

def extract_csrf_token(response):
    soup = BeautifulSoup(response.text, 'html.parser')
    token_elem = soup.find('input', {'name': 'user_token'})
    if token_elem:
        return token_elem['value']
    return None

def perform_login(use_https=False):
    # Adjust URL scheme if testing HTTPS
    url = LOGIN_ACTION.replace("http://", "https://") if use_https else LOGIN_ACTION

    try:
        # Step 1: Get login page
        resp = requests.get(url, headers=headers, verify=False, timeout=10)
        if resp.status_code != 200:
            return False, None, "Failed to load login page"

        # Extract CSRF token if present
        csrf_token = extract_csrf_token(resp)
        data = {
            'username': DUMMY_USER,
            'password': DUMMY_PASS,
            'Login': 'Login'
        }
        if csrf_token:
            data['user_token'] = csrf_token

        # Step 2: Submit login
        login_resp = requests.post(url, data=data, headers=headers, allow_redirects=True, verify=False)

        # Return whether request was made over HTTPS and response
        used_https = login_resp.url.startswith("https://") or url.startswith("https://")
        return used_https, login_resp, "Success"

    except requests.exceptions.SSLError:
        return False, None, "SSL Error: Target may not support HTTPS"
    except requests.exceptions.RequestException as e:
        return False, None, str(e)

def check_https_supported():
    try:
        https_url = LOGIN_ACTION.replace("http://", "https://")
        resp = requests.get(https_url, headers=headers, verify=False, timeout=10)
        return resp.status_code in [200, 301, 302, 307]
    except:
        return False

def generate_html_report(result, findings, recommendations, poc):
    report_name = "OTG-AUTHN-001_Report.html"
    date_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    status_color = "#cc0000" if "Failed" in result else "#008800"

    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OTG-AUTHN-001 Security Assessment Report</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background-color: #f4f4f4;
            color: #000;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        header {{
            background-color: #003366;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.4em;
            margin: -20px -20px 20px -20px;
        }}
        h1, h2, h3 {{
            color: #003366;
            border-bottom: 1px solid #003366;
            padding-bottom: 5px;
        }}
        .field {{
            margin-bottom: 10px;
        }}
        .label {{
            font-weight: bold;
            display: inline-block;
            width: 180px;
        }}
        .value {{
            display: inline;
        }}
        .status {{
            color: {status_color};
            font-weight: bold;
        }}
        pre {{
            background: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            overflow: auto;
            font-size: 0.9em;
        }}
        footer {{
            margin-top: 30px;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }}
        .risk {{
            font-weight: bold;
            color: #cc0000;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            OWASP Web Security Testing Guide - OTG-AUTHN-001
        </header>

        <h1>OTG-AUTHN-001: Credentials Transported over an Encrypted Channel</h1>

        <div class="field"><span class="label">Test Date:</span> <span class="value">{date_str}</span></div>
        <div class="field"><span class="label">Target URL:</span> <span class="value">{TARGET_URL}</span></div>
        <div class="field"><span class="label">Test Result:</span> <span class="value status">{result}</span></div>

        <h2>Vulnerability Description</h2>
        <p>
            During the authentication process, user credentials (username and password) must be transmitted over an encrypted channel (e.g., HTTPS with TLS). 
            If credentials are sent over an unencrypted HTTP connection, they are vulnerable to interception via man-in-the-middle (MITM) attacks, 
            packet sniffing, or proxy logging on untrusted networks.
        </p>
        <p>
            In this test, the login form submission was analyzed to determine whether the request was made over a secure (HTTPS) connection.
        </p>

        <h2>Impact</h2>
        <p class="risk">Medium to High</p>
        <p>
            An attacker capable of eavesdropping on network traffic (e.g., on public Wi-Fi) can capture plaintext credentials and gain unauthorized access 
            to user accounts. This compromises the confidentiality and integrity of the entire application.
        </p>

        <h2>Test Findings</h2>
        <pre>{findings}</pre>

        <h2>Proof of Concept (PoC)</h2>
        <p>The following request demonstrates how credentials are transmitted:</p>
        <pre><code>{poc}</code></pre>

        <h2>Remediation / Recommendations</h2>
        <p>{recommendations}</p>

        <h2>References</h2>
        <ul>
            <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authentication_Testing/01-Testing_for_Credentials_Transported_over_an_Encrypted_Channel" target="_blank">
                OWASP WSTG - OTG-AUTHN-001</a></li>
            <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" target="_blank">
                OWASP Authentication Cheat Sheet</a></li>
            <li>Enforce HTTPS using HSTS headers and redirect all HTTP traffic to HTTPS.</li>
        </ul>

        <footer>
            OSCP-Style Security Assessment Report | Generated by OTG-AUTHN-001 Tester
        </footer>
    </div>
</body>
</html>
    """

    with open(report_name, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"[+] Report generated: {report_name}")

def main():
    banner()

    print("[+] Testing connectivity to target...")
    connected, resp_or_err = test_connection()
    if not connected:
        print(f"[-] Failed to connect to {TARGET_URL}")
        print(f"Error: {resp_or_err}")
        return

    print("[+] Checking if login is performed over HTTPS...")
    used_https, login_resp, msg = perform_login(use_https=False)

    # Determine result
    if used_https:
        result = "Passed"
        finding = "The login form submits credentials over HTTPS. No vulnerability detected."
        rec = "The application already uses HTTPS for authentication. Ensure HSTS is enabled and certificates are valid."
        poc = ""
    else:
        result = "Failed"
        finding = "Credentials are transmitted over an unencrypted HTTP channel. This exposes authentication data to network interception."
        rec = """
Enable and enforce HTTPS for all authentication pages:
1. Obtain a valid TLS certificate (e.g., Let's Encrypt).
2. Redirect all HTTP requests to HTTPS using 301 redirects.
3. Set the 'Secure' flag on all cookies.
4. Implement HSTS (HTTP Strict Transport Security) header:
   Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
5. Disable HTTP entirely if possible.
"""
        # Generate PoC cURL
        csrf = extract_csrf_token(resp_or_err)
        csrf_str = f" -d \"user_token={csrf}\"" if csrf else ""
        poc = f'''curl -X POST "{LOGIN_ACTION}" \\
  -H "Content-Type: application/x-www-form-urlencoded" \\
  -d "username={DUMMY_USER}" \\
  -d "password={DUMMY_PASS}" \\
  -d "Login=Login"{csrf_str}'''

    # Check if HTTPS is supported but not enforced
    if not used_https and check_https_supported():
        finding += "\n\nNote: The server appears to support HTTPS, but does not enforce it for login. This represents a configuration weakness."

    print(f"[!] Vulnerability: {'Not Found' if used_https else 'FOUND'}")
    generate_html_report(result, finding, rec.strip(), poc.strip())

    print(f"[+] Test completed. Report saved.")

if __name__ == "__main__":
    main()