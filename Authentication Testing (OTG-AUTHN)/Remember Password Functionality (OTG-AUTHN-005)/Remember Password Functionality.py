# otg_authn_005_tester.py
# OTG-AUTHN-005: Testing for Remember Password Functionality
# OSCP-Style Vulnerability Tester for DVWA (localhost XAMPP)
# Generated by AI Security Assistant

import requests
import datetime
import base64
import re
from bs4 import BeautifulSoup
import urllib3

# Disable SSL warnings for localhost
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# === CONFIGURATION ===
BASE_URL = "http://localhost/dvwa"
LOGIN_URL = f"{BASE_URL}/login.php"
INDEX_URL = f"{BASE_URL}/index.php"
USER_AGENT = "OTG-AUTHN-005 Tester v1.0"
USERNAME = "admin"
PASSWORD = "password"

# Headers
headers = {
    'User-Agent': USER_AGENT,
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Connection': 'close'
}

def banner():
    print(r"""
    =====================================================
     OTG-AUTHN-005 - Testing Remember Password Functionality
             OSCP-Style Security Assessment
    =====================================================
    """)

def test_connection():
    try:
        resp = requests.get(LOGIN_URL, headers=headers, timeout=10, verify=False)
        if resp.status_code == 200:
            return True, resp
        else:
            return False, resp.status_code
    except requests.exceptions.RequestException as e:
        return False, str(e)

def extract_csrf_token(response):
    soup = BeautifulSoup(response.text, 'html.parser')
    token_elem = soup.find('input', {'name': 'user_token'})
    if token_elem:
        return token_elem['value']
    return None

def analyze_cookies(cookies):
    """Analyze cookies for security issues"""
    findings = []
    insecure_cookies = []
    
    for cookie in cookies:
        name = cookie.name
        value = cookie.value
        secure = cookie.secure
        httponly = cookie.has_nonstandard_attr('HttpOnly') or 'httponly' in str(cookie).lower()
        samesite = cookie.get_nonstandard_attr('SameSite') or 'none'
        
        # Check if cookie name suggests it might be a remember token
        remember_indicators = ['remember', 'token', 'auth', 'persistent', 'stay']
        is_remember_cookie = any(indicator in name.lower() for indicator in remember_indicators)
        
        cookie_info = {
            'name': name,
            'value': value,
            'secure': secure,
            'httponly': httponly,
            'samesite': samesite,
            'is_remember': is_remember_cookie,
            'expires': cookie.expires
        }
        
        # Check for security issues
        issues = []
        if not secure:
            issues.append("Missing Secure flag")
        if not httponly:
            issues.append("Missing HttpOnly flag")
        if samesite.lower() not in ['strict', 'lax']:
            issues.append(f"Weak SameSite policy: {samesite}")
        
        # Check for sensitive data in cookie value
        if any(sensitive in value.lower() for sensitive in [USERNAME, PASSWORD]):
            issues.append("Contains sensitive data (username/password)")
        
        # Check for weak encoding (base64, simple encoding)
        try:
            if len(value) > 4 and value.isalnum():
                # Try to decode as base64
                try:
                    decoded = base64.b64decode(value)
                    if USERNAME in decoded.decode('utf-8', errors='ignore') or PASSWORD in decoded.decode('utf-8', errors='ignore'):
                        issues.append("Contains base64-encoded sensitive data")
                except:
                    pass
        except:
            pass
        
        # Check for predictable patterns
        if re.match(r'^[0-9]+$', value) or re.match(r'^[a-f0-9]{32}$', value):
            issues.append("Predictable or weak token format")
        
        cookie_info['issues'] = issues
        findings.append(cookie_info)
        
        if issues and is_remember_cookie:
            insecure_cookies.append(cookie_info)
    
    return findings, insecure_cookies

def test_remember_functionality():
    """Test remember password functionality"""
    findings = []
    
    # Test 1: Normal login without remember me
    print("[→] Testing normal login...")
    session1 = requests.Session()
    
    try:
        # Get login page
        resp = session1.get(LOGIN_URL, headers=headers, verify=False, timeout=10)
        csrf_token = extract_csrf_token(resp)
        
        # Login without remember me
        data = {
            'username': USERNAME,
            'password': PASSWORD,
            'Login': 'Login'
        }
        if csrf_token:
            data['user_token'] = csrf_token
            
        login_resp = session1.post(LOGIN_URL, data=data, headers=headers, verify=False)
        
        # Analyze cookies
        cookie_analysis, insecure_cookies = analyze_cookies(session1.cookies)
        findings.append({
            'test': 'Normal Login',
            'cookies': cookie_analysis,
            'insecure_cookies': insecure_cookies,
            'response': login_resp
        })
        
    except Exception as e:
        findings.append({
            'test': 'Normal Login',
            'error': str(e)
        })
    
    # Test 2: Simulate remember me by adding a remember parameter
    print("[→] Testing simulated 'Remember Me' login...")
    session2 = requests.Session()
    
    try:
        # Get login page
        resp = session2.get(LOGIN_URL, headers=headers, verify=False, timeout=10)
        csrf_token = extract_csrf_token(resp)
        
        # Login with simulated remember me
        data = {
            'username': USERNAME,
            'password': PASSWORD,
            'Login': 'Login',
            'remember': 'yes'  # Simulate remember me
        }
        if csrf_token:
            data['user_token'] = csrf_token
            
        login_resp = session2.post(LOGIN_URL, data=data, headers=headers, verify=False)
        
        # Analyze cookies
        cookie_analysis, insecure_cookies = analyze_cookies(session2.cookies)
        findings.append({
            'test': 'Simulated Remember Me',
            'cookies': cookie_analysis,
            'insecure_cookies': insecure_cookies,
            'response': login_resp
        })
        
    except Exception as e:
        findings.append({
            'test': 'Simulated Remember Me',
            'error': str(e)
        })
    
    # Test 3: Check for persistent tokens in cookies
    print("[→] Analyzing for persistent authentication tokens...")
    persistent_tokens = []
    
    for finding in findings:
        if 'cookies' in finding:
            for cookie in finding['cookies']:
                if cookie['is_remember']:
                    persistent_tokens.append(cookie)
    
    # Test 4: Check token revocation (logout test)
    print("[→] Testing token revocation on logout...")
    logout_test_result = "Not Applicable"
    if len(findings) > 0 and 'cookies' in findings[0]:
        # Try to access protected page after logout
        try:
            # Logout
            logout_url = f"{BASE_URL}/logout.php"
            logout_resp = session1.get(logout_url, headers=headers, verify=False)
            
            # Try to access index page with old session
            index_resp = session1.get(INDEX_URL, headers=headers, verify=False)
            if "login.php" in index_resp.url or "Login" in index_resp.text:
                logout_test_result = "PASSED - Token properly revoked"
            else:
                logout_test_result = "FAILED - Token not revoked after logout"
        except:
            logout_test_result = "ERROR - Could not test token revocation"
    
    return findings, persistent_tokens, logout_test_result

def check_session_fixation():
    """Check for session fixation vulnerability"""
    print("[→] Testing for session fixation...")
    
    try:
        # Create session with predefined cookie
        session = requests.Session()
        session.cookies.set('PHPSESSID', 'testsession123')
        
        # Get login page
        resp = session.get(LOGIN_URL, headers=headers, verify=False, timeout=10)
        csrf_token = extract_csrf_token(resp)
        
        # Login
        data = {
            'username': USERNAME,
            'password': PASSWORD,
            'Login': 'Login'
        }
        if csrf_token:
            data['user_token'] = csrf_token
            
        login_resp = session.post(LOGIN_URL, data=data, headers=headers, verify=False)
        
        # Check if session ID changed
        new_session_id = session.cookies.get('PHPSESSID')
        if new_session_id == 'testsession123':
            return "FAILED - Session fixation possible"
        else:
            return "PASSED - Session ID regenerated"
            
    except Exception as e:
        return f"ERROR - {str(e)}"

def generate_html_report(result, findings, poc, recommendations):
    report_name = "OTG-AUTHN-005_Report.html"
    date_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    status_color = "#cc0000" if "Failed" in result else "#008800"

    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OTG-AUTHN-005 Security Assessment Report</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background-color: #f4f4f4;
            color: #000;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        header {{
            background-color: #003366;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.4em;
            margin: -20px -20px 20px -20px;
        }}
        h1, h2, h3 {{
            color: #003366;
            border-bottom: 1px solid #003366;
            padding-bottom: 5px;
        }}
        .field {{
            margin-bottom: 10px;
        }}
        .label {{
            font-weight: bold;
            display: inline-block;
            width: 200px;
        }}
        .value {{
            display: inline;
        }}
        .status {{
            color: {status_color};
            font-weight: bold;
        }}
        pre {{
            background: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            overflow: auto;
            font-size: 0.9em;
        }}
        footer {{
            margin-top: 30px;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }}
        .risk {{
            font-weight: bold;
            color: #cc0000;
        }}
        .success {{
            color: #008800;
            font-weight: bold;
        }}
        .failed {{
            color: #cc0000;
            font-weight: bold;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        .vulnerable {{
            background-color: #ffe6e6;
        }}
        .secure {{
            background-color: #e6ffe6;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            OWASP Web Security Testing Guide - OTG-AUTHN-005
        </header>

        <h1>OTG-AUTHN-005: Testing for Remember Password Functionality</h1>

        <div class="field"><span class="label">Test Date:</span> <span class="value">{date_str}</span></div>
        <div class="field"><span class="label">Target URL:</span> <span class="value">{BASE_URL}</span></div>
        <div class="field"><span class="label">Test Result:</span> <span class="value status">{result}</span></div>

        <h2>Vulnerability Description</h2>
        <p>
            The "Remember Me" or "Remember Password" functionality allows users to remain authenticated 
            across browser sessions by storing authentication tokens. When implemented insecurely, this 
            feature can lead to long-term unauthorized access, session hijacking, and credential exposure.
        </p>
        <p>
            This test evaluates the security of any persistent authentication mechanisms, including 
            cookie-based tokens, their storage security, and proper revocation practices.
        </p>

        <h2>Impact</h2>
        <p class="risk">Medium</p>
        <p>
            Insecure "Remember Me" implementations can allow attackers to gain long-term access to 
            user accounts, even after the original session has ended. This can lead to persistent 
            unauthorized access and potential account takeover.
        </p>

        <h2>Test Findings</h2>
        <pre>{findings}</pre>

        <h2>Proof of Concept (PoC)</h2>
        <p>The following examples demonstrate insecure remember password implementations:</p>
        <pre><code>{poc}</code></pre>

        <h2>Remediation / Recommendations</h2>
        <p>{recommendations}</p>

        <h2>References</h2>
        <ul>
            <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authentication_Testing/05-Testing_for_Rember_Password_Functionality" target="_blank">
                OWASP WSTG - OTG-AUTHN-005</a></li>
            <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#remember-me-feature" target="_blank">
                OWASP Authentication Cheat Sheet - Remember Me</a></li>
            <li><a href="https://owasp.org/www-project-top-ten/2017/A03_2017-Sensitive_Data_Exposure" target="_blank">
                OWASP Top 10 - A03:2017 Sensitive Data Exposure</a></li>
            <li>Use cryptographically secure random tokens with sufficient entropy.</li>
            <li>Store tokens securely with HttpOnly, Secure, and SameSite flags.</li>
            <li>Implement proper token expiration and revocation mechanisms.</li>
            <li>Never store actual credentials or predictable tokens.</li>
        </ul>

        <footer>
            OSCP-Style Security Assessment Report | Generated by OTG-AUTHN-005 Tester
        </footer>
    </div>
</body>
</html>
    """

    with open(report_name, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"[+] Report generated: {report_name}")

def main():
    banner()

    print("[+] Starting OTG-AUTHN-005 test...")
    
    # Test connectivity
    print("[✓] Testing connectivity to target...")
    connected, resp_or_err = test_connection()
    if not connected:
        print(f"[-] Failed to connect to {LOGIN_URL}")
        print(f"Error: {resp_or_err}")
        return

    print(f"[✓] Connected to {LOGIN_URL}")

    # Test remember password functionality
    findings, persistent_tokens, logout_result = test_remember_functionality()
    
    # Test session fixation
    session_fixation_result = check_session_fixation()
    
    # Analyze results
    all_findings = []
    insecure_implementations = []
    
    # Process findings
    for finding in findings:
        if 'error' in finding:
            all_findings.append(f"ERROR in {finding['test']}: {finding['error']}\n")
            continue
            
        test_name = finding['test']
        cookies = finding['cookies']
        insecure_cookies = finding['insecure_cookies']
        
        finding_text = f"{test_name} Results:\n"
        finding_text += f"  Total Cookies Set: {len(cookies)}\n"
        
        for cookie in cookies:
            finding_text += f"    Cookie: {cookie['name']} = {cookie['value'][:50]}{'...' if len(cookie['value']) > 50 else ''}\n"
            finding_text += f"      Secure: {'YES' if cookie['secure'] else 'NO'}\n"
            finding_text += f"      HttpOnly: {'YES' if cookie['httponly'] else 'NO'}\n"
            finding_text += f"      SameSite: {cookie['samesite']}\n"
            finding_text += f"      Remember Cookie: {'YES' if cookie['is_remember'] else 'NO'}\n"
            if cookie['issues']:
                finding_text += f"      Issues: {', '.join(cookie['issues'])}\n"
            finding_text += "\n"
        
        all_findings.append(finding_text)
        
        if insecure_cookies:
            for cookie in insecure_cookies:
                insecure_implementations.append({
                    'test': test_name,
                    'cookie': cookie
                })
    
    # Add logout test result
    all_findings.append(f"Token Revocation Test: {logout_result}\n")
    if "FAILED" in logout_result:
        insecure_implementations.append({
            'test': 'Token Revocation',
            'issue': 'Tokens not revoked on logout'
        })
    
    # Add session fixation result
    all_findings.append(f"Session Fixation Test: {session_fixation_result}\n")
    if "FAILED" in session_fixation_result:
        insecure_implementations.append({
            'test': 'Session Fixation',
            'issue': 'Session fixation possible'
        })
    
    # Add persistent token analysis
    if persistent_tokens:
        token_analysis = "Persistent Authentication Tokens Found:\n"
        for token in persistent_tokens:
            token_analysis += f"  Name: {token['name']}\n"
            token_analysis += f"  Value: {token['value'][:50]}{'...' if len(token['value']) > 50 else ''}\n"
            token_analysis += f"  Expires: {token['expires']}\n"
            token_analysis += f"  Issues: {', '.join(token['issues']) if token['issues'] else 'None'}\n\n"
        all_findings.append(token_analysis)
    else:
        all_findings.append("No persistent authentication tokens found.\n")

    findings_text = "".join(all_findings)
    
    # Generate report
    if insecure_implementations or persistent_tokens:
        result = "Failed"
        
        # Generate PoC
        poc_examples = []
        
        for impl in insecure_implementations:
            if 'cookie' in impl:
                cookie = impl['cookie']
                poc_examples.append(f"# Insecure cookie found in {impl['test']}:")
                poc_examples.append(f"Set-Cookie: {cookie['name']}={cookie['value']}")
                if cookie['issues']:
                    poc_examples.append(f"# Issues: {', '.join(cookie['issues'])}")
            elif 'issue' in impl:
                poc_examples.append(f"# {impl['test']}: {impl['issue']}")
        
        if persistent_tokens:
            poc_examples.append("\n# Example of accessing protected resource with persistent token:")
            poc_examples.append(f"curl -b 'PHPSESSID=...; {persistent_tokens[0]['name']}={persistent_tokens[0]['value']}' '{INDEX_URL}'")
        
        poc = "\n".join(poc_examples)
        
        recommendations = """
The application contains insecure "Remember Password" functionality that must be addressed:

1. Never store actual credentials (username/password) in cookies or tokens.
2. Use cryptographically secure random tokens with at least 128 bits of entropy.
3. Set proper cookie security flags:
   - Secure: Ensure cookies are only sent over HTTPS
   - HttpOnly: Prevent client-side script access
   - SameSite: Set to 'Strict' or 'Lax' to prevent CSRF
4. Implement proper token expiration (e.g., 30 days maximum).
5. Revoke tokens immediately on logout and password change.
6. Regenerate session IDs after successful login to prevent session fixation.
7. Store tokens securely on the server-side with proper validation.
8. Log and monitor suspicious token usage patterns.
9. Implement rate limiting on token validation endpoints.
"""
    else:
        result = "Passed"
        findings_text += "\nNo insecure remember password functionality detected.\n"
        findings_text += "The application either doesn't implement this feature or implements it securely.\n"
        poc = "No insecure implementations found."
        
        recommendations = """
The application does not appear to have insecure "Remember Password" functionality. 
However, continue to follow these best practices:

1. If implementing "Remember Me" functionality, use secure token-based approaches.
2. Always use cryptographically secure random tokens with sufficient entropy.
3. Store tokens securely with HttpOnly, Secure, and SameSite flags.
4. Implement proper token expiration and revocation mechanisms.
5. Regenerate session IDs after login to prevent session fixation.
6. Never store actual credentials in persistent storage.
7. Regularly audit authentication mechanisms for security issues.
8. Conduct security testing on all authentication features.
"""

    generate_html_report(result, findings_text, poc, recommendations)
    print("[+] Test completed.")

if __name__ == "__main__":
    main()